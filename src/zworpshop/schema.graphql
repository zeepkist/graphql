"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Favorite`."""
  allFavorites(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Favorite`."""
    orderBy: [FavoritesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FavoriteCondition
  ): FavoritesConnection

  """Reads and enables pagination through a set of `LevelPoint`."""
  allLevelPoints(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `LevelPoint`."""
    orderBy: [LevelPointsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LevelPointCondition
  ): LevelPointsConnection

  """Reads and enables pagination through a set of `Level`."""
  allLevels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Level`."""
    orderBy: [LevelsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LevelCondition
  ): LevelsConnection

  """Reads and enables pagination through a set of `Media`."""
  allMedia(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Media`."""
    orderBy: [MediaOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MediaCondition
  ): MediaConnection

  """Reads and enables pagination through a set of `Metadatum`."""
  allMetadata(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Metadatum`."""
    orderBy: [MetadataOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetadatumCondition
  ): MetadataConnection

  """Reads and enables pagination through a set of `PersonalBest`."""
  allPersonalBests(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PersonalBest`."""
    orderBy: [PersonalBestsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonalBestCondition
  ): PersonalBestsConnection

  """Reads and enables pagination through a set of `PlayerPoint`."""
  allPlayerPoints(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlayerPoint`."""
    orderBy: [PlayerPointsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerPointCondition
  ): PlayerPointsConnection

  """Reads and enables pagination through a set of `Record`."""
  allRecords(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Record`."""
    orderBy: [RecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RecordCondition
  ): RecordsConnection

  """Reads and enables pagination through a set of `Request`."""
  allRequests(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Request`."""
    orderBy: [RequestsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RequestCondition
  ): RequestsConnection

  """Reads and enables pagination through a set of `Stat`."""
  allStats(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Stat`."""
    orderBy: [StatsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StatCondition
  ): StatsConnection

  """Reads and enables pagination through a set of `Upvote`."""
  allUpvotes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Upvote`."""
    orderBy: [UpvotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpvoteCondition
  ): UpvotesConnection

  """Reads and enables pagination through a set of `User`."""
  allUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition
  ): UsersConnection

  """Reads and enables pagination through a set of `Version`."""
  allVersions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Version`."""
    orderBy: [VersionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VersionCondition
  ): VersionsConnection

  """Reads and enables pagination through a set of `Vote`."""
  allVotes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection

  """Reads and enables pagination through a set of `WorldRecord`."""
  allWorldRecords(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `WorldRecord`."""
    orderBy: [WorldRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorldRecordCondition
  ): WorldRecordsConnection
  favoriteById(id: Int!): Favorite
  levelPointById(id: Int!): LevelPoint
  mediaById(id: Int!): Media
  personalBestById(id: Int!): PersonalBest
  playerPointById(id: Int!): PlayerPoint
  recordById(id: Int!): Record
  statById(id: Int!): Stat
  upvoteById(id: Int!): Upvote
  userById(id: Int!): User
  versionById(id: Int!): Version
  voteById(id: Int!): Vote
  worldRecordById(id: Int!): WorldRecord

  """Reads a single `Favorite` using its globally unique `ID`."""
  favorite(
    """The globally unique `ID` to be used in selecting a single `Favorite`."""
    nodeId: ID!
  ): Favorite

  """Reads a single `LevelPoint` using its globally unique `ID`."""
  levelPoint(
    """
    The globally unique `ID` to be used in selecting a single `LevelPoint`.
    """
    nodeId: ID!
  ): LevelPoint

  """Reads a single `Media` using its globally unique `ID`."""
  media(
    """The globally unique `ID` to be used in selecting a single `Media`."""
    nodeId: ID!
  ): Media

  """Reads a single `PersonalBest` using its globally unique `ID`."""
  personalBest(
    """
    The globally unique `ID` to be used in selecting a single `PersonalBest`.
    """
    nodeId: ID!
  ): PersonalBest

  """Reads a single `PlayerPoint` using its globally unique `ID`."""
  playerPoint(
    """
    The globally unique `ID` to be used in selecting a single `PlayerPoint`.
    """
    nodeId: ID!
  ): PlayerPoint

  """Reads a single `Record` using its globally unique `ID`."""
  record(
    """The globally unique `ID` to be used in selecting a single `Record`."""
    nodeId: ID!
  ): Record

  """Reads a single `Stat` using its globally unique `ID`."""
  stat(
    """The globally unique `ID` to be used in selecting a single `Stat`."""
    nodeId: ID!
  ): Stat

  """Reads a single `Upvote` using its globally unique `ID`."""
  upvote(
    """The globally unique `ID` to be used in selecting a single `Upvote`."""
    nodeId: ID!
  ): Upvote

  """Reads a single `User` using its globally unique `ID`."""
  user(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User

  """Reads a single `Version` using its globally unique `ID`."""
  version(
    """The globally unique `ID` to be used in selecting a single `Version`."""
    nodeId: ID!
  ): Version

  """Reads a single `Vote` using its globally unique `ID`."""
  vote(
    """The globally unique `ID` to be used in selecting a single `Vote`."""
    nodeId: ID!
  ): Vote

  """Reads a single `WorldRecord` using its globally unique `ID`."""
  worldRecord(
    """
    The globally unique `ID` to be used in selecting a single `WorldRecord`.
    """
    nodeId: ID!
  ): WorldRecord
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Favorite` values."""
type FavoritesConnection {
  """A list of `Favorite` objects."""
  nodes: [Favorite]!

  """
  A list of edges which contains the `Favorite` and cursor to aid in pagination.
  """
  edges: [FavoritesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Favorite` you could get from the connection."""
  totalCount: Int!
}

type Favorite implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  user: Int!
  level: String!
  dateCreated: Datetime!
  dateUpdated: Datetime!

  """Reads a single `User` that is related to this `Favorite`."""
  userByUser: User
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  steamId: String
  steamName: String
  discordId: String
  banned: Boolean!
  dateCreated: Datetime!
  dateUpdated: Datetime!

  """Reads and enables pagination through a set of `Favorite`."""
  favoritesByUser(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Favorite`."""
    orderBy: [FavoritesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FavoriteCondition
  ): FavoritesConnection!

  """Reads and enables pagination through a set of `Record`."""
  recordsByUser(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Record`."""
    orderBy: [RecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RecordCondition
  ): RecordsConnection!

  """Reads and enables pagination through a set of `Stat`."""
  statsByUser(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Stat`."""
    orderBy: [StatsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StatCondition
  ): StatsConnection!

  """Reads and enables pagination through a set of `Upvote`."""
  upvotesByUser(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Upvote`."""
    orderBy: [UpvotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpvoteCondition
  ): UpvotesConnection!

  """Reads and enables pagination through a set of `Vote`."""
  votesByUser(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection!

  """Reads and enables pagination through a set of `PersonalBest`."""
  personalBestsByUser(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PersonalBest`."""
    orderBy: [PersonalBestsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonalBestCondition
  ): PersonalBestsConnection!

  """Reads and enables pagination through a set of `WorldRecord`."""
  worldRecordsByUser(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `WorldRecord`."""
    orderBy: [WorldRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorldRecordCondition
  ): WorldRecordsConnection!

  """Reads and enables pagination through a set of `PlayerPoint`."""
  playerPointsByUser(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlayerPoint`."""
    orderBy: [PlayerPointsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerPointCondition
  ): PlayerPointsConnection!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Methods to use when ordering `Favorite`."""
enum FavoritesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ASC
  USER_DESC
  LEVEL_ASC
  LEVEL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Favorite` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input FavoriteCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `user` field."""
  user: Int

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A connection to a list of `Record` values."""
type RecordsConnection {
  """A list of `Record` objects."""
  nodes: [Record]!

  """
  A list of edges which contains the `Record` and cursor to aid in pagination.
  """
  edges: [RecordsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Record` you could get from the connection."""
  totalCount: Int!
}

type Record implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  user: Int!
  time: Float!
  splits: String
  gameVersion: String!
  isValid: Boolean!
  level: String!
  modVersion: String!
  dateCreated: Datetime!
  dateUpdated: Datetime!

  """Reads a single `User` that is related to this `Record`."""
  userByUser: User

  """Reads and enables pagination through a set of `Media`."""
  mediaByRecord(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Media`."""
    orderBy: [MediaOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MediaCondition
  ): MediaConnection!

  """Reads and enables pagination through a set of `PersonalBest`."""
  personalBestsByRecord(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PersonalBest`."""
    orderBy: [PersonalBestsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonalBestCondition
  ): PersonalBestsConnection!

  """Reads and enables pagination through a set of `WorldRecord`."""
  worldRecordsByRecord(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `WorldRecord`."""
    orderBy: [WorldRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorldRecordCondition
  ): WorldRecordsConnection!
}

"""A connection to a list of `Media` values."""
type MediaConnection {
  """A list of `Media` objects."""
  nodes: [Media]!

  """
  A list of edges which contains the `Media` and cursor to aid in pagination.
  """
  edges: [MediaEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Media` you could get from the connection."""
  totalCount: Int!
}

type Media implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  record: Int!
  ghostUrl: String!
  screenshotUrl: String!
  dateCreated: Datetime!
  dateUpdated: Datetime!

  """Reads a single `Record` that is related to this `Media`."""
  recordByRecord: Record
}

"""A `Media` edge in the connection."""
type MediaEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Media` at the end of the edge."""
  node: Media
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `Media`."""
enum MediaOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  RECORD_ASC
  RECORD_DESC
  GHOST_URL_ASC
  GHOST_URL_DESC
  SCREENSHOT_URL_ASC
  SCREENSHOT_URL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Media` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MediaCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `record` field."""
  record: Int

  """Checks for equality with the object’s `ghostUrl` field."""
  ghostUrl: String

  """Checks for equality with the object’s `screenshotUrl` field."""
  screenshotUrl: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A connection to a list of `PersonalBest` values."""
type PersonalBestsConnection {
  """A list of `PersonalBest` objects."""
  nodes: [PersonalBest]!

  """
  A list of edges which contains the `PersonalBest` and cursor to aid in pagination.
  """
  edges: [PersonalBestsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PersonalBest` you could get from the connection."""
  totalCount: Int!
}

type PersonalBest implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  record: Int!
  user: Int!
  periodStart: Datetime
  periodEnd: Datetime
  level: String!
  dateCreated: Datetime!
  dateUpdated: Datetime!

  """Reads a single `Record` that is related to this `PersonalBest`."""
  recordByRecord: Record

  """Reads a single `User` that is related to this `PersonalBest`."""
  userByUser: User
}

"""A `PersonalBest` edge in the connection."""
type PersonalBestsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PersonalBest` at the end of the edge."""
  node: PersonalBest
}

"""Methods to use when ordering `PersonalBest`."""
enum PersonalBestsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  RECORD_ASC
  RECORD_DESC
  USER_ASC
  USER_DESC
  PERIOD_START_ASC
  PERIOD_START_DESC
  PERIOD_END_ASC
  PERIOD_END_DESC
  LEVEL_ASC
  LEVEL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `PersonalBest` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PersonalBestCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `record` field."""
  record: Int

  """Checks for equality with the object’s `user` field."""
  user: Int

  """Checks for equality with the object’s `periodStart` field."""
  periodStart: Datetime

  """Checks for equality with the object’s `periodEnd` field."""
  periodEnd: Datetime

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A connection to a list of `WorldRecord` values."""
type WorldRecordsConnection {
  """A list of `WorldRecord` objects."""
  nodes: [WorldRecord]!

  """
  A list of edges which contains the `WorldRecord` and cursor to aid in pagination.
  """
  edges: [WorldRecordsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `WorldRecord` you could get from the connection."""
  totalCount: Int!
}

type WorldRecord implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  record: Int!
  user: Int!
  periodStart: Datetime
  periodEnd: Datetime
  level: String!
  dateCreated: Datetime!
  dateUpdated: Datetime!

  """Reads a single `Record` that is related to this `WorldRecord`."""
  recordByRecord: Record

  """Reads a single `User` that is related to this `WorldRecord`."""
  userByUser: User
}

"""A `WorldRecord` edge in the connection."""
type WorldRecordsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `WorldRecord` at the end of the edge."""
  node: WorldRecord
}

"""Methods to use when ordering `WorldRecord`."""
enum WorldRecordsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  RECORD_ASC
  RECORD_DESC
  USER_ASC
  USER_DESC
  PERIOD_START_ASC
  PERIOD_START_DESC
  PERIOD_END_ASC
  PERIOD_END_DESC
  LEVEL_ASC
  LEVEL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `WorldRecord` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input WorldRecordCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `record` field."""
  record: Int

  """Checks for equality with the object’s `user` field."""
  user: Int

  """Checks for equality with the object’s `periodStart` field."""
  periodStart: Datetime

  """Checks for equality with the object’s `periodEnd` field."""
  periodEnd: Datetime

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A `Record` edge in the connection."""
type RecordsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Record` at the end of the edge."""
  node: Record
}

"""Methods to use when ordering `Record`."""
enum RecordsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ASC
  USER_DESC
  TIME_ASC
  TIME_DESC
  SPLITS_ASC
  SPLITS_DESC
  GAME_VERSION_ASC
  GAME_VERSION_DESC
  IS_VALID_ASC
  IS_VALID_DESC
  LEVEL_ASC
  LEVEL_DESC
  MOD_VERSION_ASC
  MOD_VERSION_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Record` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RecordCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `user` field."""
  user: Int

  """Checks for equality with the object’s `time` field."""
  time: Float

  """Checks for equality with the object’s `splits` field."""
  splits: String

  """Checks for equality with the object’s `gameVersion` field."""
  gameVersion: String

  """Checks for equality with the object’s `isValid` field."""
  isValid: Boolean

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `modVersion` field."""
  modVersion: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A connection to a list of `Stat` values."""
type StatsConnection {
  """A list of `Stat` objects."""
  nodes: [Stat]!

  """
  A list of edges which contains the `Stat` and cursor to aid in pagination.
  """
  edges: [StatsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Stat` you could get from the connection."""
  totalCount: Int!
}

type Stat implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  crashTotal: Int!
  crashRegular: Int!
  crashEye: Int!
  crashGhost: Int!
  crashSticky: Int!
  distanceArmsUp: Float!
  distanceBraking: Float!
  distanceGrounded: Float!
  distanceInAir: Float!
  distanceOnNoWheels: Float!
  distanceOnOneWheel: Float!
  distanceOnTwoWheels: Float!
  distanceOnThreeWheels: Float!
  distanceOnFourWheels: Float!
  distanceRagdoll: Float!
  distanceWithNoWheels: Float!
  distanceWithOneWheel: Float!
  distanceWithTwoWheels: Float!
  distanceWithThreeWheels: Float!
  distanceWithFourWheels: Float!
  distanceOnRegular: Float!
  distanceOnGrass: Float!
  distanceOnIce: Float!
  timeArmsUp: Float!
  timeBraking: Float!
  timeGrounded: Float!
  timeInAir: Float!
  timeOnNoWheels: Float!
  timeOnOneWheel: Float!
  timeOnTwoWheels: Float!
  timeOnThreeWheels: Float!
  timeOnFourWheels: Float!
  timeRagdoll: Float!
  timeWithNoWheels: Float!
  timeWithOneWheel: Float!
  timeWithTwoWheels: Float!
  timeWithThreeWheels: Float!
  timeWithFourWheels: Float!
  timeOnRegular: Float!
  timeOnGrass: Float!
  timeOnIce: Float!
  timesStarted: Int!
  timesFinished: Int!
  wheelsBroken: Int!
  checkpointsCrossed: Int!
  user: Int!
  month: Int!
  year: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime!
  level: String

  """Reads a single `User` that is related to this `Stat`."""
  userByUser: User
}

"""A `Stat` edge in the connection."""
type StatsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Stat` at the end of the edge."""
  node: Stat
}

"""Methods to use when ordering `Stat`."""
enum StatsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CRASH_TOTAL_ASC
  CRASH_TOTAL_DESC
  CRASH_REGULAR_ASC
  CRASH_REGULAR_DESC
  CRASH_EYE_ASC
  CRASH_EYE_DESC
  CRASH_GHOST_ASC
  CRASH_GHOST_DESC
  CRASH_STICKY_ASC
  CRASH_STICKY_DESC
  DISTANCE_ARMS_UP_ASC
  DISTANCE_ARMS_UP_DESC
  DISTANCE_BRAKING_ASC
  DISTANCE_BRAKING_DESC
  DISTANCE_GROUNDED_ASC
  DISTANCE_GROUNDED_DESC
  DISTANCE_IN_AIR_ASC
  DISTANCE_IN_AIR_DESC
  DISTANCE_ON_NO_WHEELS_ASC
  DISTANCE_ON_NO_WHEELS_DESC
  DISTANCE_ON_ONE_WHEEL_ASC
  DISTANCE_ON_ONE_WHEEL_DESC
  DISTANCE_ON_TWO_WHEELS_ASC
  DISTANCE_ON_TWO_WHEELS_DESC
  DISTANCE_ON_THREE_WHEELS_ASC
  DISTANCE_ON_THREE_WHEELS_DESC
  DISTANCE_ON_FOUR_WHEELS_ASC
  DISTANCE_ON_FOUR_WHEELS_DESC
  DISTANCE_RAGDOLL_ASC
  DISTANCE_RAGDOLL_DESC
  DISTANCE_WITH_NO_WHEELS_ASC
  DISTANCE_WITH_NO_WHEELS_DESC
  DISTANCE_WITH_ONE_WHEEL_ASC
  DISTANCE_WITH_ONE_WHEEL_DESC
  DISTANCE_WITH_TWO_WHEELS_ASC
  DISTANCE_WITH_TWO_WHEELS_DESC
  DISTANCE_WITH_THREE_WHEELS_ASC
  DISTANCE_WITH_THREE_WHEELS_DESC
  DISTANCE_WITH_FOUR_WHEELS_ASC
  DISTANCE_WITH_FOUR_WHEELS_DESC
  DISTANCE_ON_REGULAR_ASC
  DISTANCE_ON_REGULAR_DESC
  DISTANCE_ON_GRASS_ASC
  DISTANCE_ON_GRASS_DESC
  DISTANCE_ON_ICE_ASC
  DISTANCE_ON_ICE_DESC
  TIME_ARMS_UP_ASC
  TIME_ARMS_UP_DESC
  TIME_BRAKING_ASC
  TIME_BRAKING_DESC
  TIME_GROUNDED_ASC
  TIME_GROUNDED_DESC
  TIME_IN_AIR_ASC
  TIME_IN_AIR_DESC
  TIME_ON_NO_WHEELS_ASC
  TIME_ON_NO_WHEELS_DESC
  TIME_ON_ONE_WHEEL_ASC
  TIME_ON_ONE_WHEEL_DESC
  TIME_ON_TWO_WHEELS_ASC
  TIME_ON_TWO_WHEELS_DESC
  TIME_ON_THREE_WHEELS_ASC
  TIME_ON_THREE_WHEELS_DESC
  TIME_ON_FOUR_WHEELS_ASC
  TIME_ON_FOUR_WHEELS_DESC
  TIME_RAGDOLL_ASC
  TIME_RAGDOLL_DESC
  TIME_WITH_NO_WHEELS_ASC
  TIME_WITH_NO_WHEELS_DESC
  TIME_WITH_ONE_WHEEL_ASC
  TIME_WITH_ONE_WHEEL_DESC
  TIME_WITH_TWO_WHEELS_ASC
  TIME_WITH_TWO_WHEELS_DESC
  TIME_WITH_THREE_WHEELS_ASC
  TIME_WITH_THREE_WHEELS_DESC
  TIME_WITH_FOUR_WHEELS_ASC
  TIME_WITH_FOUR_WHEELS_DESC
  TIME_ON_REGULAR_ASC
  TIME_ON_REGULAR_DESC
  TIME_ON_GRASS_ASC
  TIME_ON_GRASS_DESC
  TIME_ON_ICE_ASC
  TIME_ON_ICE_DESC
  TIMES_STARTED_ASC
  TIMES_STARTED_DESC
  TIMES_FINISHED_ASC
  TIMES_FINISHED_DESC
  WHEELS_BROKEN_ASC
  WHEELS_BROKEN_DESC
  CHECKPOINTS_CROSSED_ASC
  CHECKPOINTS_CROSSED_DESC
  USER_ASC
  USER_DESC
  MONTH_ASC
  MONTH_DESC
  YEAR_ASC
  YEAR_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  LEVEL_ASC
  LEVEL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Stat` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StatCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `crashTotal` field."""
  crashTotal: Int

  """Checks for equality with the object’s `crashRegular` field."""
  crashRegular: Int

  """Checks for equality with the object’s `crashEye` field."""
  crashEye: Int

  """Checks for equality with the object’s `crashGhost` field."""
  crashGhost: Int

  """Checks for equality with the object’s `crashSticky` field."""
  crashSticky: Int

  """Checks for equality with the object’s `distanceArmsUp` field."""
  distanceArmsUp: Float

  """Checks for equality with the object’s `distanceBraking` field."""
  distanceBraking: Float

  """Checks for equality with the object’s `distanceGrounded` field."""
  distanceGrounded: Float

  """Checks for equality with the object’s `distanceInAir` field."""
  distanceInAir: Float

  """Checks for equality with the object’s `distanceOnNoWheels` field."""
  distanceOnNoWheels: Float

  """Checks for equality with the object’s `distanceOnOneWheel` field."""
  distanceOnOneWheel: Float

  """Checks for equality with the object’s `distanceOnTwoWheels` field."""
  distanceOnTwoWheels: Float

  """Checks for equality with the object’s `distanceOnThreeWheels` field."""
  distanceOnThreeWheels: Float

  """Checks for equality with the object’s `distanceOnFourWheels` field."""
  distanceOnFourWheels: Float

  """Checks for equality with the object’s `distanceRagdoll` field."""
  distanceRagdoll: Float

  """Checks for equality with the object’s `distanceWithNoWheels` field."""
  distanceWithNoWheels: Float

  """Checks for equality with the object’s `distanceWithOneWheel` field."""
  distanceWithOneWheel: Float

  """Checks for equality with the object’s `distanceWithTwoWheels` field."""
  distanceWithTwoWheels: Float

  """Checks for equality with the object’s `distanceWithThreeWheels` field."""
  distanceWithThreeWheels: Float

  """Checks for equality with the object’s `distanceWithFourWheels` field."""
  distanceWithFourWheels: Float

  """Checks for equality with the object’s `distanceOnRegular` field."""
  distanceOnRegular: Float

  """Checks for equality with the object’s `distanceOnGrass` field."""
  distanceOnGrass: Float

  """Checks for equality with the object’s `distanceOnIce` field."""
  distanceOnIce: Float

  """Checks for equality with the object’s `timeArmsUp` field."""
  timeArmsUp: Float

  """Checks for equality with the object’s `timeBraking` field."""
  timeBraking: Float

  """Checks for equality with the object’s `timeGrounded` field."""
  timeGrounded: Float

  """Checks for equality with the object’s `timeInAir` field."""
  timeInAir: Float

  """Checks for equality with the object’s `timeOnNoWheels` field."""
  timeOnNoWheels: Float

  """Checks for equality with the object’s `timeOnOneWheel` field."""
  timeOnOneWheel: Float

  """Checks for equality with the object’s `timeOnTwoWheels` field."""
  timeOnTwoWheels: Float

  """Checks for equality with the object’s `timeOnThreeWheels` field."""
  timeOnThreeWheels: Float

  """Checks for equality with the object’s `timeOnFourWheels` field."""
  timeOnFourWheels: Float

  """Checks for equality with the object’s `timeRagdoll` field."""
  timeRagdoll: Float

  """Checks for equality with the object’s `timeWithNoWheels` field."""
  timeWithNoWheels: Float

  """Checks for equality with the object’s `timeWithOneWheel` field."""
  timeWithOneWheel: Float

  """Checks for equality with the object’s `timeWithTwoWheels` field."""
  timeWithTwoWheels: Float

  """Checks for equality with the object’s `timeWithThreeWheels` field."""
  timeWithThreeWheels: Float

  """Checks for equality with the object’s `timeWithFourWheels` field."""
  timeWithFourWheels: Float

  """Checks for equality with the object’s `timeOnRegular` field."""
  timeOnRegular: Float

  """Checks for equality with the object’s `timeOnGrass` field."""
  timeOnGrass: Float

  """Checks for equality with the object’s `timeOnIce` field."""
  timeOnIce: Float

  """Checks for equality with the object’s `timesStarted` field."""
  timesStarted: Int

  """Checks for equality with the object’s `timesFinished` field."""
  timesFinished: Int

  """Checks for equality with the object’s `wheelsBroken` field."""
  wheelsBroken: Int

  """Checks for equality with the object’s `checkpointsCrossed` field."""
  checkpointsCrossed: Int

  """Checks for equality with the object’s `user` field."""
  user: Int

  """Checks for equality with the object’s `month` field."""
  month: Int

  """Checks for equality with the object’s `year` field."""
  year: Int

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime

  """Checks for equality with the object’s `level` field."""
  level: String
}

"""A connection to a list of `Upvote` values."""
type UpvotesConnection {
  """A list of `Upvote` objects."""
  nodes: [Upvote]!

  """
  A list of edges which contains the `Upvote` and cursor to aid in pagination.
  """
  edges: [UpvotesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Upvote` you could get from the connection."""
  totalCount: Int!
}

type Upvote implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  user: Int!
  level: String!
  dateCreated: Datetime!
  dateUpdated: Datetime!

  """Reads a single `User` that is related to this `Upvote`."""
  userByUser: User
}

"""A `Upvote` edge in the connection."""
type UpvotesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Upvote` at the end of the edge."""
  node: Upvote
}

"""Methods to use when ordering `Upvote`."""
enum UpvotesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ASC
  USER_DESC
  LEVEL_ASC
  LEVEL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Upvote` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UpvoteCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `user` field."""
  user: Int

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A connection to a list of `Vote` values."""
type VotesConnection {
  """A list of `Vote` objects."""
  nodes: [Vote]!

  """
  A list of edges which contains the `Vote` and cursor to aid in pagination.
  """
  edges: [VotesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Vote` you could get from the connection."""
  totalCount: Int!
}

type Vote implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  user: Int!
  score: Int!
  level: String!
  dateCreated: Datetime!
  dateUpdated: Datetime!

  """Reads a single `User` that is related to this `Vote`."""
  userByUser: User
}

"""A `Vote` edge in the connection."""
type VotesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Vote` at the end of the edge."""
  node: Vote
}

"""Methods to use when ordering `Vote`."""
enum VotesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ASC
  USER_DESC
  SCORE_ASC
  SCORE_DESC
  LEVEL_ASC
  LEVEL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Vote` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input VoteCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `user` field."""
  user: Int

  """Checks for equality with the object’s `score` field."""
  score: Int

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A connection to a list of `PlayerPoint` values."""
type PlayerPointsConnection {
  """A list of `PlayerPoint` objects."""
  nodes: [PlayerPoint]!

  """
  A list of edges which contains the `PlayerPoint` and cursor to aid in pagination.
  """
  edges: [PlayerPointsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PlayerPoint` you could get from the connection."""
  totalCount: Int!
}

type PlayerPoint implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  user: Int!
  points: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime!
  rank: Int!
  worldRecords: Int

  """Reads a single `User` that is related to this `PlayerPoint`."""
  userByUser: User
}

"""A `PlayerPoint` edge in the connection."""
type PlayerPointsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PlayerPoint` at the end of the edge."""
  node: PlayerPoint
}

"""Methods to use when ordering `PlayerPoint`."""
enum PlayerPointsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ASC
  USER_DESC
  POINTS_ASC
  POINTS_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  RANK_ASC
  RANK_DESC
  WORLD_RECORDS_ASC
  WORLD_RECORDS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `PlayerPoint` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input PlayerPointCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `user` field."""
  user: Int

  """Checks for equality with the object’s `points` field."""
  points: Int

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime

  """Checks for equality with the object’s `rank` field."""
  rank: Int

  """Checks for equality with the object’s `worldRecords` field."""
  worldRecords: Int
}

"""A `Favorite` edge in the connection."""
type FavoritesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Favorite` at the end of the edge."""
  node: Favorite
}

"""A connection to a list of `LevelPoint` values."""
type LevelPointsConnection {
  """A list of `LevelPoint` objects."""
  nodes: [LevelPoint]!

  """
  A list of edges which contains the `LevelPoint` and cursor to aid in pagination.
  """
  edges: [LevelPointsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `LevelPoint` you could get from the connection."""
  totalCount: Int!
}

type LevelPoint implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  level: String!
  points: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime!
}

"""A `LevelPoint` edge in the connection."""
type LevelPointsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `LevelPoint` at the end of the edge."""
  node: LevelPoint
}

"""Methods to use when ordering `LevelPoint`."""
enum LevelPointsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  LEVEL_ASC
  LEVEL_DESC
  POINTS_ASC
  POINTS_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LevelPoint` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LevelPointCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `points` field."""
  points: Int

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A connection to a list of `Level` values."""
type LevelsConnection {
  """A list of `Level` objects."""
  nodes: [Level]!

  """
  A list of edges which contains the `Level` and cursor to aid in pagination.
  """
  edges: [LevelsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Level` you could get from the connection."""
  totalCount: Int!
}

type Level {
  id: Int!
  name: String!
  imageUrl: String!
  createdAt: Datetime!
  updatedAt: Datetime!
  workshopId: BigFloat!
  authorId: BigFloat!
  fileHash: String!
  fileUrl: String!
  fileAuthor: String!
  fileUid: String!
  replacedBy: Int
  deleted: Boolean!
  metadataId: Int!
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""A `Level` edge in the connection."""
type LevelsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Level` at the end of the edge."""
  node: Level
}

"""Methods to use when ordering `Level`."""
enum LevelsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_URL_ASC
  IMAGE_URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  WORKSHOP_ID_ASC
  WORKSHOP_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  FILE_HASH_ASC
  FILE_HASH_DESC
  FILE_URL_ASC
  FILE_URL_DESC
  FILE_AUTHOR_ASC
  FILE_AUTHOR_DESC
  FILE_UID_ASC
  FILE_UID_DESC
  REPLACED_BY_ASC
  REPLACED_BY_DESC
  DELETED_ASC
  DELETED_DESC
  METADATA_ID_ASC
  METADATA_ID_DESC
}

"""
A condition to be used against `Level` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input LevelCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `imageUrl` field."""
  imageUrl: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `workshopId` field."""
  workshopId: BigFloat

  """Checks for equality with the object’s `authorId` field."""
  authorId: BigFloat

  """Checks for equality with the object’s `fileHash` field."""
  fileHash: String

  """Checks for equality with the object’s `fileUrl` field."""
  fileUrl: String

  """Checks for equality with the object’s `fileAuthor` field."""
  fileAuthor: String

  """Checks for equality with the object’s `fileUid` field."""
  fileUid: String

  """Checks for equality with the object’s `replacedBy` field."""
  replacedBy: Int

  """Checks for equality with the object’s `deleted` field."""
  deleted: Boolean

  """Checks for equality with the object’s `metadataId` field."""
  metadataId: Int
}

"""A connection to a list of `Metadatum` values."""
type MetadataConnection {
  """A list of `Metadatum` objects."""
  nodes: [Metadatum]!

  """
  A list of edges which contains the `Metadatum` and cursor to aid in pagination.
  """
  edges: [MetadataEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Metadatum` you could get from the connection."""
  totalCount: Int!
}

type Metadatum {
  hash: String!
  valid: Boolean!
  checkpoints: Int!
  blocks: String!
  validation: Float!
  gold: Float!
  silver: Float!
  bronze: Float!
  ground: Int!
  skybox: Int!
  id: Int!
}

"""A `Metadatum` edge in the connection."""
type MetadataEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Metadatum` at the end of the edge."""
  node: Metadatum
}

"""Methods to use when ordering `Metadatum`."""
enum MetadataOrderBy {
  NATURAL
  HASH_ASC
  HASH_DESC
  VALID_ASC
  VALID_DESC
  CHECKPOINTS_ASC
  CHECKPOINTS_DESC
  BLOCKS_ASC
  BLOCKS_DESC
  VALIDATION_ASC
  VALIDATION_DESC
  GOLD_ASC
  GOLD_DESC
  SILVER_ASC
  SILVER_DESC
  BRONZE_ASC
  BRONZE_DESC
  GROUND_ASC
  GROUND_DESC
  SKYBOX_ASC
  SKYBOX_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against `Metadatum` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input MetadatumCondition {
  """Checks for equality with the object’s `hash` field."""
  hash: String

  """Checks for equality with the object’s `valid` field."""
  valid: Boolean

  """Checks for equality with the object’s `checkpoints` field."""
  checkpoints: Int

  """Checks for equality with the object’s `blocks` field."""
  blocks: String

  """Checks for equality with the object’s `validation` field."""
  validation: Float

  """Checks for equality with the object’s `gold` field."""
  gold: Float

  """Checks for equality with the object’s `silver` field."""
  silver: Float

  """Checks for equality with the object’s `bronze` field."""
  bronze: Float

  """Checks for equality with the object’s `ground` field."""
  ground: Int

  """Checks for equality with the object’s `skybox` field."""
  skybox: Int

  """Checks for equality with the object’s `id` field."""
  id: Int
}

"""A connection to a list of `Request` values."""
type RequestsConnection {
  """A list of `Request` objects."""
  nodes: [Request]!

  """
  A list of edges which contains the `Request` and cursor to aid in pagination.
  """
  edges: [RequestsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Request` you could get from the connection."""
  totalCount: Int!
}

type Request {
  id: Int!
  workshopId: BigFloat!
  uid: String
  hash: String
  dateCreated: Datetime!
}

"""A `Request` edge in the connection."""
type RequestsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Request` at the end of the edge."""
  node: Request
}

"""Methods to use when ordering `Request`."""
enum RequestsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  WORKSHOP_ID_ASC
  WORKSHOP_ID_DESC
  UID_ASC
  UID_DESC
  HASH_ASC
  HASH_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
}

"""
A condition to be used against `Request` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RequestCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `workshopId` field."""
  workshopId: BigFloat

  """Checks for equality with the object’s `uid` field."""
  uid: String

  """Checks for equality with the object’s `hash` field."""
  hash: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  STEAM_ID_ASC
  STEAM_ID_DESC
  STEAM_NAME_ASC
  STEAM_NAME_DESC
  DISCORD_ID_ASC
  DISCORD_ID_DESC
  BANNED_ASC
  BANNED_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `steamId` field."""
  steamId: String

  """Checks for equality with the object’s `steamName` field."""
  steamName: String

  """Checks for equality with the object’s `discordId` field."""
  discordId: String

  """Checks for equality with the object’s `banned` field."""
  banned: Boolean

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}

"""A connection to a list of `Version` values."""
type VersionsConnection {
  """A list of `Version` objects."""
  nodes: [Version]!

  """
  A list of edges which contains the `Version` and cursor to aid in pagination.
  """
  edges: [VersionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Version` you could get from the connection."""
  totalCount: Int!
}

type Version implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  minimum: String
  latest: String
  dateCreated: Datetime!
  dateUpdated: Datetime!
}

"""A `Version` edge in the connection."""
type VersionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Version` at the end of the edge."""
  node: Version
}

"""Methods to use when ordering `Version`."""
enum VersionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MINIMUM_ASC
  MINIMUM_DESC
  LATEST_ASC
  LATEST_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Version` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input VersionCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `minimum` field."""
  minimum: String

  """Checks for equality with the object’s `latest` field."""
  latest: String

  """Checks for equality with the object’s `dateCreated` field."""
  dateCreated: Datetime

  """Checks for equality with the object’s `dateUpdated` field."""
  dateUpdated: Datetime
}